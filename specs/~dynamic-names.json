{
  "overview": "Dynamic Names are a special way to dynamically refer to a tag name.\n\nDynamic Names MUST be a non-whitespace character sequence NOT containing\nthe current closing delimiter.\n\nThis tag's content refers to a key in the context whose value will be used in\nplace of the Dynamic Name itself as content of the tag. The name resolution is\nas follows:\n  1) Split the name on periods; the first part is the name to resolve, any\n  remaining parts should be retained.\n  2) Walk the context stack from top to bottom, finding the first context\n  that is a) a hash containing the name as a key OR b) an object responding\n  to a method with the given name.\n  3) If the context is a hash, the data is the value associated with the\n  name.\n  4) If the context is an object, the data is the value returned by the\n  method with the given name.\n  5) If any name parts were retained in step 1, each should be resolved\n  against a context stack containing only the result from the former\n  resolution.  If any part fails resolution, the result should be considered\n  falsey, and should interpolate as the empty string.\nThe resolved data should be coerced into a string before being used as\ncontent.\n\nSet Delimiter tags MUST NOT affect the resolution of a Dynamic Name. The\nDynamic Names MUST be rendered against the context stack local to the tag.\nFailed resolutions of the key (context lookups) should be considered falsey\nand should interpolate as the empty string.\n\nDynamic Names can be combined with every other tag: those tags' content is the\nresolution of the Dynamic Name. Dynamic Names cannot be resolved more than\nonce (Dynamic Names cannot be nested).\n",
  "tests": [
    {
      "name": "Basic Behavior - Interpolation",
      "desc": "The asterisk operator is used for dynamic names.",
      "data": {
        "dynamic": "Hello, world!"
      },
      "template": "\"{{*dynamic}}\"",
      "partials": {},
      "expected": "\"Hello, world!\""
    },
    {
      "name": "Basic Behavior - Partial",
      "desc": "The asterisk operator is used for dynamic partials.",
      "data": {
        "dynamic": "content"
      },
      "template": "\"{{>*dynamic}}\"",
      "partials": {
        "content": "Hello, world!"
      },
      "expected": "\"Hello, world!\""
    },
    {
      "name": "Context Misses - Interpolation",
      "desc": "Failed context lookups should be considered falsey.",
      "data": {},
      "template": "\"{{*missing}}\"",
      "partials": {},
      "expected": "\"\""
    },
    {
      "name": "Context Misses - Partial",
      "desc": "Failed context lookups should be considered falsey.",
      "data": {},
      "template": "\"{{>*missing}}\"",
      "partials": {
        "missing": "Hello, world!"
      },
      "expected": "\"\""
    },
    {
      "name": "Failed Lookup - Partial",
      "desc": "The empty string should be used when the named partial is not found.",
      "data": {
        "dynamic": "content"
      },
      "template": "\"{{>*dynamic}}\"",
      "partials": {
        "foobar": "Hello, world!"
      },
      "expected": "\"\""
    },
    {
      "name": "Context",
      "desc": "The asterisk operator should operate within the current context.",
      "data": {
        "text": "Hello, world!",
        "example": "partial"
      },
      "template": "\"{{*example}}\"",
      "partials": {
        "partial": "*{{text}}*"
      },
      "expected": "\"*Hello, world!*\""
    },
    {
      "name": "Recursion",
      "desc": "The asterisk operator should properly recurse.",
      "data": {
        "template": "node",
        "content": "X",
        "nodes": [
          {
            "content": "Y",
            "nodes": []
          }
        ]
      },
      "template": "{{*template}}",
      "partials": {
        "node": "{{content}}<{{#nodes}}{{*template}}{{/nodes}}>"
      },
      "expected": "X<Y<>>"
    },
    {
      "name": "Surrounding Whitespace",
      "desc": "The asterisk operator should not alter surrounding whitespace; any\nwhitespace preceding the tag should treated as indentation while any\nwhitepsace succeding the tag should be left untouched.\n",
      "data": {
        "partial": "foobar"
      },
      "template": "| {{*partial}} |",
      "partials": {
        "foobar": "\t|\t"
      },
      "expected": "| \t|\t |"
    },
    {
      "name": "Inline Indentation",
      "desc": "Whitespace should be left untouched: whitespaces preceding the tag\nshould be treated as indentation.\n",
      "data": {
        "dynamic": "partial",
        "data": "|"
      },
      "template": "  {{data}}  {{* dynamic}}\n",
      "partials": {
        "partial": ">\n>"
      },
      "expected": "  |  >\n>\n"
    },
    {
      "name": "Standalone Line Endings",
      "desc": "\"\\r\\n\" should be considered a newline for standalone tags.",
      "data": {
        "dynamic": "partial"
      },
      "template": "|\r\n{{*dynamic}}\r\n|",
      "partials": {
        "partial": ">"
      },
      "expected": "|\r\n>|"
    },
    {
      "name": "Standalone Without Previous Line",
      "desc": "Standalone tags should not require a newline to precede them.",
      "data": {
        "dynamic": "partial"
      },
      "template": "  {{*dynamic}}\n>",
      "partials": {
        "partial": ">\n>"
      },
      "expected": "  >\n  >>"
    },
    {
      "name": "Standalone Without Newline",
      "desc": "Standalone tags should not require a newline to follow them.",
      "data": {
        "dynamic": "partial"
      },
      "template": ">\n  {{*dynamic}}",
      "partials": {
        "partial": ">\n>"
      },
      "expected": ">\n  >\n  >"
    },
    {
      "name": "Standalone Indentation",
      "desc": "Each line of the partial should be indented before rendering.",
      "data": {
        "dynamic": "partial",
        "content": "<\n->"
      },
      "template": "\\\n {{*dynamic}}\n/\n",
      "partials": {
        "partial": "|\n{{{content}}}\n|\n"
      },
      "expected": "\\\n |\n <\n->\n |\n/\n"
    },
    {
      "name": "Padding Whitespace",
      "desc": "Superfluous in-tag whitespace should be ignored.",
      "data": {
        "dynamic": "partial",
        "boolean": true
      },
      "template": "|{{* dynamic }}|",
      "partials": {
        "partial": "[]"
      },
      "expected": "|[]|"
    }
  ]
}
